Go 语言提供了一系列内置函数，这些函数是语言的核心部分，可以直接使用，无需导入任何包。像 `copy` 函数一样，这些内置函数覆盖了从基本数据操作到更复杂的内存和控制结构等多种功能。下面是一些常用的 Go 语言内置函数：

1. **`len()`**
   - 返回容器（如数组、切片、字符串、map 或通道）的长度或元素数量。
   - 示例：`len("hello")` 返回 5。

2. **`cap()`**
   - 返回切片或通道的容量。
   - 示例：对于切片 `s := make([]int, 3, 5)`，`cap(s)` 返回 5。

3. **`append()`**
   - 向切片添加一个或多个元素，并返回结果切片。
   - 示例：`s := append(s, 2, 3, 4)`

4. **`make()`**
   - 用于分配并初始化一个切片、map 或通道。
   - 示例：`s := make([]int, 10)` 创建一个长度为 10 的整型切片。

5. **`new()`**
   - 分配内存，返回指向该类型的零值的指针。
   - 示例：`p := new(int)` 创建一个指向整数零值的指针。

6. **`close()`**
   - 用于关闭通道，之后不能再向通道发送值。
   - 示例：`close(ch)`

7. **`delete()`**
   - 从 map 中删除键及其对应的值。
   - 示例：`delete(m, key)`

8. **`panic()`**
   - 触发一个运行时恐慌（panic），可用于生成一个错误并立即停止常规的流程控制。
   - 示例：`panic("something went wrong")`

9. **`recover()`**
   - 用于终止一个恐慌（panic）序列，并返回传递给 `panic` 调用的值。
   - 示例：
     ```go
     func safeDo() {
         defer func() {
             if r := recover(); r != nil {
                 fmt.Println("Recovered in safeDo:", r)
             }
         }()
         panic("not good")
     }
     ```

10. **`real()` 和 `imag()`**
    - 返回复数的实部和虚部。
    - 示例：对于复数 `c := 3 + 4i`，`real(c)` 返回 3，`imag(c)` 返回 4。

11. **`complex()`**
    - 创建一个复数值。
    - 示例：`c := complex(3, 4)` 创建复数 3+4i。

这些内置函数是 Go 语言的基础，为开发者提供了强大的工具，使得内存管理、错误处理、数据结构操作等变得简单高效。
